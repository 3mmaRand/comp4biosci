{
  "hash": "137929622ebd0dfc21cbc4288e586ac2",
  "result": {
    "engine": "knitr",
    "markdown": "# First Steps in RStudio\n\n\n::: {.callout-warning} \n## First draft\nYou are reading a work in progress. This page is a first draft but should be readable.\n:::\n\nThis chapter .....\n\nRight, let's start coding!\n\n### Your first piece of code\n\nWe can use R just like a calculator. Put your cursor after the `>` in\nthe Console, type `3 + 4` and ↵ Enter to send that command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3+4\n## [1] 7\n```\n:::\n\n\nThe `>` is called the \"prompt\". You do not have to type it, it tells you\nthat R is ready for input.\n\nWhere I've written `3+4`, I have no spaces. However, you *can* have\nspaces, and in fact, it's good practice to use spaces around your\noperators because it makes your code easier to read. So a better way of\nwriting this would be:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 + 4\n## [1] 7\n```\n:::\n\n\nIn the output we have the number `7`, which, obviously, is the answer.\nFrom now on, you should assume commands typed at the console should be\nfollowed by ↵ Enter to send them.\n\nThe one in parentheses, `[1]`, is an index. It is telling you that the\n`7` is the first element of the output. We can see this more clear if we\ncreate something with more output. For example, `50:100` will print the\nnumbers from 50 to 100.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n50:100\n##  [1]  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68\n## [20]  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87\n## [39]  88  89  90  91  92  93  94  95  96  97  98  99 100\n```\n:::\n\n\nThe numbers in the square parentheses at the beginning of the line give\nyou the index of the first element in the line. R is telling you where\nyou are in the output.\n\n### Assigning variables\n\nVery often we want to keep input values or output for future use. We do\nthis with 'assignment' An assignment is a statement in programming that\nis used to set a value to a variable name. In R, the operator used to do\nassignment is `<-`. It assigns the value on the right-hand to the value\non the left-hand side.\n\nTo assign the value `3` to `x` we do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\n```\n:::\n\n\nand ↵ Enter to send that command.\n\nThe assignment operator is made of two characters, the `<` and the `-`\nand there is a keyboard short cut: Alt+- (windows) or Option+- (Mac).\nUsing the shortcut means you'll automatically get spaces. You won't see\nany output when the command has been executed because there is no\noutput. However, you will see `x` listed under Values in the Environment\ntab (top right).\n\nYour turn! Assign the value of `4` to a variable called `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ny <- 4\n```\n:::\n\n\nCheck you can see `y` listed in the Environment tab.\n\nType `x` and ↵ Enter to print the contents of `x` in the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n## [1] 3\n```\n:::\n\n\nWe can use these values in calculations just like we could in in maths\nand algebra.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + y\n## [1] 7\n```\n:::\n\n\nWe get the output of `7` just as we expect. Suppose we make a mistake\nwhen typing, for example, accidentally pressing the u button instead of\nthe y button:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + u\n## Error: object 'u' not found\n```\n:::\n\n\nWe get an error. We will probably see this error quite often - it means\nwe have tried to use a variable that is not in our Environment. So when\nyou get that error, have a quick look up at your\nenvironment[^first_steps_rstudio-1].\n\n[^first_steps_rstudio-1]: When we are using scripts, it is very easy to\n    write code but forget to run it. Very often when you see this error\n    it will because you have written the code to create an object but\n    forgotten to execute it.\n\nWe made a typo and will want to try again. We usefully have access to\nall the commands that previously entered when we use the ↑ Up Arrow.\nThis is known as command recall. Pressing the ↑ Up Arrow once recalls\nthe last command; pressing it twice recalls the command before the last\none and so on.\n\nRecall the `x + u` command (you may need to use the ↓ Down Arrow to get\nback to get it) and use the Back space key to remove the `u` and then\nadd a `y`.\n\nA lot of what we type is going to be wrong - that is not because you are\na beginner, it is same for everybody! On the whole, you type it wrong\nuntil you get it right and then you move to the next part. This means\nyou are going to have to access your previous commands often. The\nHistory - behind the Environment tab - contains everything you can see\nwith the ↑ Up Arrow. You can imagine that as you increase the number of\ncommands you run in a session, having access the this record of\neverything you did is useful. However, the thing about the history is,\nthat it has *everything* you typed, including all the wrong things!\n\nWhat we really want is a record of everything we did that was right!\nThis is why we use scripts instead of typing directly into the console.\n\n### Using Scripts\n\nAn R script is a plain text file with a `.R` extension and containing R\ncode. Instead of typing into the console, we normally type into a script\nand then send the commands to the console when we are ready to run them.\nThen if we've made any mistakes, we just correct our script and by the\nend of the session, it contains a record of everything we typed that\nworked.\n\nYou have several options open a new script:\n\n-   button: Green circle with a white cross, top left and choose R\n    Script\n-   menu: File \\| New File \\| R Script\n-   keyboard shortcut: Ctrl+Shift+N (Windows) / Shift+Command+N (Mac)\n\nOpen a script and add the two assignments to it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\ny <- 4\n```\n:::\n\n\nTo send the first line to the console, we place our cursor on the line\n(anywhere) and press Ctrl-Enter (Windows) / Command-Return. That line\nwill be executed in the console and in the script, our cursor will jump\nto the next line. Now, send the second command to the console in the\nsame way.\n\nFrom this point forward, you should assume commands should be typed into\nthe script and sent to the console.\n\nAdd the incorrect command attempting to sum the two variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + u\n## Error: object 'u' not found\n```\n:::\n\n\nTo correct this, we do not add another line to the script but instead\nedit the existing command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + y\n## [1] 7\n```\n:::\n\n\nIn addition to making it easy to keep a record of your work, scripts\nhave another big advantage, you can include 'comments' - pieces of text\nthat describe what the code is doing. Comments are indicated with a `#`\nin front of them. You can write anything you like after a `#` and R will\nrecognise that it is not code and doesn't need to be run.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This script performs the sum of two values\n\nx <- 3    # can be altered\ny <- 4    # can be altered\n\n# perform sum\nx + y\n## [1] 7\n```\n:::\n\n\nThe comments should be highlighted in a different colour than the code.\nThey will be italic in some Editor themes.\n\nYou have several options save a script:\n\n-   button: use the floppy disc icon\n-   menu: File \\| Save\n-   keyboard shortcut: Ctrl+S (Windows) / Command+S (Mac)\n\nYou could use a name like `test1.R` - note the `.R` extension wil be\nadded automatically.\n\n### Other types of file in RStudio\n\n-   `.R` script code but not the objects. You always want to save this\n-   `.Rdata` also known as the workspace or session, the objects, but\n    not the code. You usually do not want to save this. Some exceptions\n    e.g., if it takes quite a long time to run the commands.\n-   text files\n\n### Changing some defaults to make life easier\n\nI recommend changing some of the default settings to make your life a\nlittle easier. Go back into the Global Options window with Tools \\|\nGlobal Options. The top tab is General\n@fig-tools-global-options-general.\n\n::: {#fig-tools-global-options-general}\n![](images/tools-global-options-general.png)\n\n**Screenshot of RStudio's Global Options window showing the General\noptions**. Tools \\| Global Options opens a window. One of the options is\nGeneral. This where you can change the default behaviour of RStudio.\nHighlighted is the default (start up) directory and the option to Save\nand Restore the workspace.\n:::\n\nFirst, we will set our default working directory. Under 'Default working\ndirectory (when not in a project[^first_steps_rstudio-2]):' click Browse\nand navigate to a through your file system to a folder where you want to\nwork. You may want to create a folder specifically for studying this\nbook.\n\n[^first_steps_rstudio-2]: We will find out what an RStudio Project is\n    very soon. You will want to use a project for most of your work -\n    they make everything a little easier.\n\nSecond, we will change the Workspace options. Turn off 'Restore .RData\ninto workspace at startup' and change 'Save workspace to .RData on exit'\nto 'Never'. These options mean R will start up clean each time.\n\n## Recap of RStudio anatomy\n\nThis figure (see @fig-rstudio-anatomy[^first_steps_rstudio-3])\nsummarises shows what each of the four RStudio panes and what they are\nused for to summarise much of what we have covered so far.\n\n[^first_steps_rstudio-3]: You can zoom into this at the [Direct\n    link](https://www-users.york.ac.uk/~er13/RStudio%20Anatomy.svg)\n\n::: {#fig-rstudio-anatomy}\n\n::: {.cell}\n::: {.cell-output-display}\n![](http://www-users.york.ac.uk/~er13/RStudio%20Anatomy.svg)\n:::\n:::\n\n\n**A screenshot of RStudio's four panes annotated with what each pane is\nfor**. You can zoom into this at the [Direct\nlink](https://www-users.york.ac.uk/~er13/RStudio%20Anatomy.svg)\n:::\n\n## Data types and structures in R\n\nIn this section, we are going to introduce you to some of R's data types\nand structures. We won't be covering all of them now, just those you are\ngoing to use often in this part of the book. These are numerics\n(numbers), characters, 'logicals', vectors and dataframes. We can do a\nlot with just these. We will also cover using functions.\n\nWe are going to consider\n\n-   types of value also known as data types\n\n-   functions\n\n-   data structures\n\n### Data types\n\nThis refers to the type of value that something is. They might be\nnumerics or characters or 'logical' (either true of false). We assign a\nnumber, like the value of 23 to a variable called `x` like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 23\nx\n## [1] 23\n```\n:::\n\n\nWe do not need to use quotes for numbers but we do need to use them for\ncharacters and can assign the word banana to the variable `a` like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- \"banana\"\na\n## [1] \"banana\"\n```\n:::\n\n\nQuotes are needed because otherwise R wouldn't know whether you were\nreferring to a value or a existing object called `banana`. This is also\nwhy you can't have variable name like `14` - R would not be able to tell\nthe difference between the number 14 and an object named `14` since\nnumbers and objects don't need quotes.\n\nAnything composed of non-numeric characters, including single\ncharacters, need to have quotes around it. You can even force a number\nto be a character by putting quotes around it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- \"23\"\nb\n## [1] \"23\"\n```\n:::\n\n\nNotice that things inside quotes appear in a different colour (the\ncolour will depend on the Editor theme you choose). This will help you\nidentify when you have forgotten some closing quotes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- \"banana\nx <- 23\n\n```\n:::\n\n\nNotice how the `x <- 23` is in the same colour as the string \"banana\"\nbecause we forgot to close the quotes. RStudio makes it hard for you to\nforget closing quotes and parentheses because when you type an opening\nquote or parenthesis, it automatically adds its closing partner. When\npeople are learning they are sometimes tempted to delete these so they\ncan type what goes inside the quotes/parentheses and then manually add\nthe closing partner. I strongly recommend you do *not* delete them.\nRStudio adds the closing character *but* it leaves your cursor in the\nright position to complete the contents.\n\nAlthough the data type is 'character' we often use the term 'string' for\ncollections - strings - of characters\n\nWe also have special values called 'logicals' which take a value of\neither `TRUE` or `FALSE.`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc <- TRUE\nc\n## [1] TRUE\n```\n:::\n\n\nAlthough `TRUE` is a word, R recognises it as special word. It appears\nin a different colour and no quotes are needed. This is the same for\n`FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc <- FALSE\nc\n## [1] FALSE\n```\n:::\n\n\nAs you type `FALSE`, the colour changes as it recognises the special\nword `FALSE`. Try to pay attention to the editor theme's colouring - it\nis trying to help you!\n\n### Functions\n\nThe aim of this section is to help you understand the logic of using a\nfunction. Functions have a name and then a set of parentheses. The\nfunction name minimally explains what the function does. Inside the\nparentheses are 'arguments' - the pieces of information you give to the\nfunction. When coding, we often talk about passing arguments to\nfunctions and calling functions. A simple function call looks like this:\n\n``` r\nfunction_name(argument)\n```\n\nA function can take zero to many arguments. Where you give several\narguments, they are separated by commas:\n\n``` r\nfunction_name(argument1, argument2, argument3, ...)\n```\n\nThe first function you are going to use is `str()` which gives the\n**str**ucture of an object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(x)\n##  num 23\n```\n:::\n\n\nIt's telling me that `x` is a number and contains 23.\n\nYour turn! Use `str()` on `b`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstr(b)\n##  chr \"23\"\n```\n:::\n\n\n`str()` is a function I use a lot to check what sort of R object I have.\n\nWe must give `str()` at least one argument, the object we want the\nstructure of, but additional arguments are also possible. Later we will\ndiscover how to find out and use a function's arguments.\n\nSo far we our objects have consisted of a single thing but usually we\nhave several bits of data that we want to collect together into a data\nstructure.\n\n### Data structures: vectors\n\nImagine we have the ages of six people. Since all the numbers are ages,\nwe would want to keep them together. The minimal data structure is\ncalled a vector. We can create a vector, which collects together several\nnumbers using a function, `c()`. This is one of only a few functions in\nR with a single-letter name. Because it has a single letter, sometimes\npeople get confused about it but we can tell it is a function because it\nhas a set of parentheses.\n\nTo create a vector called `ages` of several numbers we use\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages <- c(23, 42, 7, 9, 54, 12)\n```\n:::\n\n\nType `ages` and run if you want to print the contents to the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages\n## [1] 23 42  7  9 54 12\n```\n:::\n\n\nUsing `str()` on `ages`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(ages)\n##  num [1:6] 23 42 7 9 54 12\n```\n:::\n\n\ntells us we have numbers with the indices of 1 to 6.\n\nWe can also create a vector of strings. Suppose we have names to go with\nthe ages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"Rowan\", \"Aang\", \"Zain\", \"Charlie\", \"Jules\", \"Efe\")\n```\n:::\n\n\nRStudio has a super useful feature for putting items in quotes, brackets\nor parentheses if you initially forget them: If you select something and\ntype the opening element, that thing will be surrounded rather than over\nwritten. For example, if you had written:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- Rowan, Aang, Zain, Charlie, Jules, Efe\n```\n:::\n\n\nSelect one of the names and then type an opening quote - you should see\nthe name is then surrounded by quotes rather than overwritten. You can\nrepeat this process for all the names (note that double clicking on the\nname will select it). Selecting the whole list and typing an opening\nparenthesis will put the whole list in parentheses. This is a feature\nyou get to love so much and use so often that other programs will annoy\nyou when you overwrite something you meant to quote!\n\nSo we can also have vectors of logical values. For example, we might\nhave a vector that indicates that Rowan, Aang and Charlie like\nchocolate, but Zain, Jules and Efe do not:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchocolate <- c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE)\n```\n:::\n\n\nRemember, because `TRUE` and `FALSE` are special words we do not need\nquote them.\n\n### Indexing vectors\n\nYou might be wondering how to get a single element out of a vector if\ntyping the vector's name prints the entire vector. This is by\n'indexing'. An index is a number from 1[^first_steps_rstudio-4] to the\nlength of a vector which gives the position in the vector and is denoted\nby square brackets. For example, to pull out the second element of\n`ages`:\n\n[^first_steps_rstudio-4]: We start counting from 1 in R. Most\n    programming languages count from zero.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages[2]\n## [1] 42\n```\n:::\n\n\nYour turn! Print the last element of `names`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nnames[6]\n## [1] \"Efe\"\n```\n:::\n\n\nWe an extract more than one element by giving more than one index. If\nthe indices are adjacent like 3rd, 4th and 5th, we have use the colon:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames[3:5]\n## [1] \"Zain\"    \"Charlie\" \"Jules\"\n```\n:::\n\n\nIf the indices are not adjacent, like 2 and 6 with need to combine them\nwith `c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames[c(2, 6)]\n## [1] \"Aang\" \"Efe\"\n```\n:::\n\n\nWe can also use a logical vector to extract elements. Suppose you want\nto extract the names and ages of the people who like chocolate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames[chocolate]\n## [1] \"Rowan\"   \"Aang\"    \"Charlie\"\nages[chocolate]\n## [1] 23 42  9\n```\n:::\n\n\nAt each of the indices in `chocolate` that contain `TRUE`, the name and\nage are returned.\n\n### Changing the defaults for a function\n\nThe functions we have used so far, `c()` and `str()` have worked without\nus having to change default behaviour. For example, if we want to\ncalculate the mean age of our people we can use the `mean()` function in\ndefault form:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(ages)\n## [1] 24.5\n```\n:::\n\n\nImagine Charlie would like their age removed from the dataset or that we\nnever knew their age. We would not want a vector containing just five\nelements because the ages would not match the people in the same\nposition in the vector. Instead, we would have a missing value at that\nposition. Missing values are `NA` (not applicable) in R and `NA` is\nanother special word, like `TRUE` and `FALSE`, that doesn't need quotes.\nWe can set Charlie's age to NA using indexing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages[names == \"Charlie\"] <- NA\nages\n## [1] 23 42  7 NA 54 12\n```\n:::\n\n\nThe `==` means \"is equal to\" and the result of `names == \"Charlie\"` is a\nvector of logicals: `FALSE FALSE FALSE  TRUE FALSE FALSE`. This means\n`ages[names == \"Charlie\"]` references the age in `ages` at the index of\nCharlie in `names`\n\nIf we now try to calculate the mean age:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(ages)\n## [1] NA\n```\n:::\n\n\nWe get an NA! What we really want is an average of the ages we do have.\nThe `mean()` function has an argument that allows you to cope with that\nsituation called `na.rm`. By default, `na.rm` is set to `FALSE` but we\ncan set it to `TRUE` using\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(ages, na.rm = TRUE)\n## [1] 27.6\n```\n:::\n\n\n### Data structures: dataframes\n\nWe have three vectors, `names`, `ages` and `chocolate` which are all\npart of the same dataset. By far the most common way of organising data\nin R is within a \"dataframe\". A dataframe, has rows and columns: each\ncolumn represents a variable and each row represents a case. To make a\ndataframe using our three vectors we use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeople <- data.frame(names, ages, chocolate)\n```\n:::\n\n\nYou will see `people` listed in the Global environment under Data. To\nopen a spreadsheet-like view of the dataframe click its name in the\nGlobal Environment @fig-view-dataframe\n\n\n::: {#fig-view-dataframe}\n![](images/view-dataframe.png)\n\n**A screenshot of RStudio showing the `people` dataframe over the script on \nthe left and the Environment pane on the right** To open a spreadsheet-like \nview of the dataframe click its name in the Global Environment.\n:::\n\n## Install your first R package\n\nWe will be using the **`tidyverse`** [@tidyverse] package in this book.\n\nInstall **`tidyverse`** like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\n*Installing* a package means downloading it from the internet and placing its \ncode on your computer. You only need to do this once -- or each time you \nupdate your version of R.\nTo use the package once it has been installed you need to *load* it with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nLoading a package means telling R you want to use functions from that package \nin an R session. You need to load packages each time you start a new R session.\n\n## Summary\n\n1.  R can be used like a calculator. Commands are typed at the console\n    prompt (`>`), and output appears below with line indices. Good\n    practice includes using spaces around operators for readability.\n\n2.  **Variables** are created using `<-` (e.g., `x <- 3`). This is\n    called **assignment**. These values can be reused in calculations,\n    and errors (like using an undefined variable) are common and part of\n    the learning process. Use the Environment tab and command history to\n    track objects and troubleshoot.\n\n3.  Rather than typing directly into the console, use `.R` **scripts**\n    to write and execute code. Scripts help keep a record of correct\n    commands and allow **comments** (using `#`) to explain code.\n\n4.  Change some of the default RStudio settings: decide a default\n    working directory and adjust workspace options to start clean each\n    time (e.g., do not restore `.RData` on startup or save workspace on\n    exit).\n\n5.  R uses basic data types like **numeric**, **character** (strings),\n    and logical (**`TRUE`**/**`FALSE`**). **Vectors** are collections of\n    values, created with `c()`. Indexing (e.g., `ages[2]`) retrieves\n    elements by position or condition.\n\n6.  **Functions** take arguments in parentheses (e.g., `mean(ages)`).\n    Some functions have default settings that can be changed (e.g.,\n    `na.rm = TRUE` to ignore missing values in `mean()`).\n\n7.  **Data frame** are rectangular and the most common structure for\n    datasets in R.\n",
    "supporting": [
      "first_steps_rstudio_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}