{
  "hash": "aee6e0645583d3f01b0fc628724d823a",
  "result": {
    "engine": "knitr",
    "markdown": "# From importing to reporting\n\n\n\n\n\n::: {.callout-warning} \n## First draft\nYou are reading a work in progress. This page is a first draft but should be readable.\n:::\n\n\n\n\nIn [First Steps in RStudio](first_steps_rstudio.html) we typed data into R. This is not very practical when you have a lot of data! Instead, we much more commonly import data from a file. In this chapter we go through the workflow from importing, through summarising and plotting to saving a saving the figure.\n\n## Importing data from files\n\nThere are two things you need to know before you can import data from a file.\n\n1.  What format the data are in\n\n    The format of the data determines what *function* you will use to import it. Often the file extension indicates format.\n\n    -   `.txt` a plain text file[^import_to_report-1], where the columns are often separated by a space but might also be separated by a tab, a backslash or forward slash, or some other character\n    -   `.csv` a plain text file where the columns are separated by commas\n    -   `.xlsx` an Excel file More detail on file types was covered in [Understanding file systems](file_systems.html#files)\n    \n    However, you should always check the file to make sure it is in the format you expect because there is little to force a match between a file's contents and the extension in its name. You can check by opening the file in a text editor (e.g., Notepad on Windows, TextEdit on Mac) or in RStudio (see below).\n\n2.  Where the file is relative to your working directory\n\n    `R` can only read in a file if you say where it is, *i.e.*, you give its **relative path**. More detail on relative file paths and working directories was covered in [Understanding file systems](file_systems.html#working-directories)\n\nðŸŽ¬ Your turn! If you want to code along you will need to start a new [RStudio project](workflow_rstudio.html#rstudio-projects) then a new script.\n\nThis chapter covers reading `.txt` files and `.csv` files using **`tidyverse`** [@tidyverse] functions and excel files using the **`readxl`** [@readxl] package. We will demonstrate what needs to be done differently if the file is not in your working directory.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readxl)\n```\n:::\n\n\n\n\n### Importing data from `.txt` file\n\nThe data in [adipocytes.txt](data-raw/adipocytes.txt) give the concentration of a hormone called adiponectin in some cells. There are two columns: the first gives the adiponectin concentration and the second, treatment, indicates whether the cells were treated with nicotinic acid or not. Save this file to the project folder.\n\nA `.txt` extension suggests this is plain text file with columns separated by spaces. However, before we attempt to read it in, when should take a look at it. We can do this from RStudio by clicking on the file in the Files pane. Any plain text file will open in the top left pane.\n\n![The adipocytes.txt data file open. We can see the columns are separated by spaces](images/text-data-file-open.png){#fig-text-data-file-open fig-alt=\"screenshot of RStudio showing the data file open\" width=\"600\"}\n\nThe files are separated by spaces as we suspected. We use the `read_table()` command to read in plain text files of single columns, or where the columns are separated by spaces:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadipo <- read_table(\"adipocytes.txt\")\n```\n:::\n\n\n\n\nThe data from the file has been read into a dataframe called `adipo`. You will and you will be able to see it in the Environment window. Clicking on it in the Environment window will open a spreadsheet-like view of the dataframe.\n\n### Importing a from a`.csv` file\n\nThe data [seal.csv](data-raw/seal.csv) give the myoglobin concentration of skeletal muscle for three species of seal. There are two columns: the first gives the myoglobin concentration and the second indicates species.\n\nThe `.csv` extension suggests this is plain text file with columns separated by commas. We will again check this before we attempt to read it in. Click on the file in the Files pane - a pop-up will appear for files ending `.csv` or `.xlsx`. Choose View File[^import_to_report-2].\n\n![Rstudio Files pane showing the data files and the View File option that appears when you click on the a particular file](images/csv-data-file-view.png){#csv-data-file-view fig-alt=\"screenshot of RStudio showing the View File option that appears when you click on the a particular file\" width=\"600\"}\n\nCSV files will open in the top left pane (Excel files will launch Excel). We can see that the file does contain comma separated values. There is a`read_csv()` function which works very like `read_table()`\\[\\^working_with_data_rstudio-3\\]:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseal <- read_csv(\"seals.csv\")\n```\n:::\n\n\n\n\n### Importing a from a`.xlsx` file\n\nThe data in [blood.xlsx](data-raw/blood.xlsx) are measurements of several blood parameters from fifty people with Crohn's disease, a lifelong condition where parts of the digestive system become inflamed. Twenty-five of people are in the early stages of diagnosis and 25 have started treatment.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblood <- read_excel(\"blood.xlsx\")\n```\n:::\n\n\n\n\n### Importing data from a file not in your working directory\n\nWhen using an RStudio project, your working directory is the project folder (the folder containing the `.Rproj` file. Suppose our file [adipocytes.txt](data-raw/adipocytes.txt) is in a folder, `data-raw`, in our working directory.\n\n```         \n-- myproject\n   |__myproject.Rproj\n   |__import.R\n   |__data-raw\n      |__adipocytes.txt\n      |__blood.xlsx\n      |__seal.csv\n```\n\nWe need to adjust the code to give the *relative path* to the datafile:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadipo <- read_table(\"data-raw/adipocytes.txt\")\n```\n:::\n\n\n\n\nThe [relative path](https://3mmarand.github.io/comp4biosci/file_systems.html#relative-paths) is the path from the working directory to the file. In this case, the working directory is `myproject` and the relative path is `data-raw/adipocytes.txt`. \n\nðŸŽ¬ Your turn! Create a folder called `data-raw` inside the project folder and move the data files to it. Now modify the data import code to import seal.csv from `data-raw`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nseal <- read_csv(\"data-raw/seal.csv\")\n```\n:::\n\n\n\n\n## Summarising data\n\nWe summarise data using the the **`dplyr`** [@dplyr] package, which provides a set of functions designed for efficient data manipulation. This is a **`tidyverse`** [@tidyverse] package which you already loaded. The approach replies on the data being in a tidy format, meaning each column represents a variable, each row represents an observation, and each cell contains a single value. The pipeline is:\n\n-   Group the data: If you want to summarize your data based on certain groups, you can use the `group_by()`\n\n-   Summarise: Once your data grouped (if necessary), you use `summarise()` with functions like` mean()`, `median()`, `sd()`, `min()`and `max()` within it.\n\nWe will demonstrate summarising using the `adipo` dataframe. `adiponectin` is the response and is continuous and `treatment` is an explanatory with categorical with two levels (groups).\n\nThe most useful summary statistics for a continuous variable like `adiponectin` are the means, standard deviations, sample sizes and standard errors. We use the `group_by()` and `summarise()` functions along with the functions that do the calculations.\n\nTo create a data frame called `adipo_summary` that contains the means, standard deviations, sample sizes and standard errors for the control and nicotinic acid treated samples:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadipo_summary <- adipo  |> \n  group_by(treatment) |>\n  summarise(mean = mean(adiponectin),\n            std = sd(adiponectin),\n            n = length(adiponectin),\n            se = std/sqrt(n))\n\n```\n:::\n\n\n\n\nYou can type:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadipo_summary\n## # A tibble: 2 Ã— 5\n##   treatment  mean   std     n    se\n##   <chr>     <dbl> <dbl> <int> <dbl>\n## 1 control    5.55  1.48    15 0.381\n## 2 nicotinic  7.51  1.79    15 0.463\n```\n:::\n\n\n\n\nor click on environment to open a spreadsheet-like view of the dataframe.\n\n### Visualise data\n\nMost commonly, we put the explanatory variable on the *x* axis and the response variable on the *y* axis. A continuous response, particularly one that follows the normal distribution, is best summarised with the mean and the standard error. In my opinion, you should also show all the raw data points if possible.\n\nWe are going to create a figure like this:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](import_to_report_files/figure-html/unnamed-chunk-11-1.png){width=576}\n:::\n:::\n\n\n\n\n#### **`ggplot2`** \n\n**`ggplot2`** [@ggplot2] is a powerful data visualisation package in R that is part of the tidyverse. It provides a flexible and layered approach to creating high-quality and customizable graphics.\n\nThe core concept of **`ggplot2`** is to build a plot layer by layer. The basic structure consists of three main components:\n\n1.  Data: the data frame to be used for plotting.\n2.  Aesthetic mappings (aes): how variables in the data map to visual elements such as *x* and *y* positions, colours, shapes, etc.\n3.  Geometric objects (geoms): the actual graphical elements used to visualize the data, such as points, lines, bars, etc.\n\n\nTo create a basic plot, you start with the `ggplot()` function and provide the data and aesthetic mappings.\n\n```\nggplot(data = adipo, aes(x = treatment, y = adiponectin))\n\n```\n\nYou can add geometric layers to the plot using specific functions such as `geom_point()`, `geom_line()`, `geom_bar()`, etc. These functions define the type of plot you want to create:\n\n\n```\nggplot(data = adipo, aes(x = treatment, y = adiponectin)) +\n  geom_point()\n\n```\n\n\nIn the figure we are aiming for, we are plotting two dataframes: the `adipo` dataframe which contains the data points themselves; and the `adipo_summary` dataframe containing and the means and standard errors.\n\nThe dataframes and aesthetics for ggplot can be specified *within a `geom_xxxx`* (rather than in the `ggplot()`). This is very useful if the geom only applies to some of the data you want to plot.\n\n::: callout-tip\n## Tip: `ggplot()`\n\nYou put the `data` argument and `aes()` inside `ggplot()` if you want all the `geoms` to use that dataframe and variables. If you want a different dataframe for a `geom`, put the `data` argument and `aes()` inside the `geom_xxxx()`\n:::\n\nI will build the plot up in small steps you should edit your *existing* `ggplot()` command as we go.\n\nWe will plot the data points first. Notice that we have given the data argument and the aesthetics *inside* the `geom_point()`. The variables `treatment` and `adiponectin` are in the `adipo` dataframe\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, \n             aes(x = treatment, y = adiponectin))\n```\n\n::: {.cell-output-display}\n![](import_to_report_files/figure-html/unnamed-chunk-12-1.png){width=576}\n:::\n:::\n\n\n\n\nSo the data points don't overlap, we can add some random jitter in the *x* direction (edit your existing code):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, \n             aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0))\n```\n\n::: {.cell-output-display}\n![](import_to_report_files/figure-html/unnamed-chunk-13-1.png){width=576}\n:::\n:::\n\n\n\n\nNote that `position = position_jitter(width = 0.1, height = 0)` is inside the `geom_point()` parentheses, after the `aes()` and a comma.\n\nWe've set the vertical jitter to 0 because, in contrast to the categorical *x*-axis, movement on the *y*-axis has meaning (the adiponectin levels).\n\nLet's make the points a light grey (edit your existing code):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, \n             aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"grey50\")\n```\n\n::: {.cell-output-display}\n![](import_to_report_files/figure-html/unnamed-chunk-14-1.png){width=576}\n:::\n:::\n\n\n\n\nNow to add the errorbars. These go from one standard error below the mean to one standard error above the mean.\n\nAdd a `geom_errorbar()` for errorbars (edit your existing code):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"grey50\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) \n```\n\n::: {.cell-output-display}\n![](import_to_report_files/figure-html/unnamed-chunk-15-1.png){width=576}\n:::\n:::\n\n\n\n\nWe have specified the `adipo_summary` dataframe and the variables `treatment`, `mean` and `se` are in that.\n\nThere are several ways you could add the mean. You could use `geom_point()` but I like to use `geom_errorbar()` again with the `ymin` and `ymax` both set to the mean.\n\nAdd a `geom_errorbar()` for the mean (edit your existing code):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"grey50\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean, ymax = mean),\n                width = 0.2)\n```\n\n::: {.cell-output-display}\n![](import_to_report_files/figure-html/unnamed-chunk-16-1.png){width=576}\n:::\n:::\n\n\n\n\nAlter the axis labels and limits using `scale_y_continuous()` and `scale_x_discrete()` (edit your existing code):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"grey50\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean, ymax = mean),\n                width = 0.2) +\n  scale_y_continuous(name = \"Adiponectin (pg/mL)\", \n                     limits = c(0, 12), \n                     expand = c(0, 0)) +\n  scale_x_discrete(name = \"Treatment\", \n                   labels = c(\"Control\", \"Nicotinic acid\"))\n```\n\n::: {.cell-output-display}\n![](import_to_report_files/figure-html/unnamed-chunk-17-1.png){width=576}\n:::\n:::\n\n\n\n\nYou only need to use `scale_y_continuous()` and `scale_x_discrete()` to use labels that are different from those in the dataset. Often this is to use proper terminology and captialisation.\n\nFormat the figure in a way that is more suitable for including in a report using `theme_classic()` (edit your existing code):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"gray50\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean, ymax = mean),\n                width = 0.2) +\n  scale_y_continuous(name = \"Adiponectin (pg/mL)\", \n                     limits = c(0, 12), \n                     expand = c(0, 0)) +\n  scale_x_discrete(name = \"Treatment\", \n                   labels = c(\"Control\", \"Nicotinic acid\")) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](import_to_report_files/figure-html/unnamed-chunk-18-1.png){width=576}\n:::\n:::\n\n\n\n\n[^import_to_report-1]: Plain text files can be opened in notepad or other similar editor and still be readable.\n\n[^import_to_report-2]: There is also and option to import the dataset. **Do not**Â be tempted to import data this way! Unless you are careful and know what you are doing, your data import will not be scripted or will not be scripted correctly.\n\nThe `ggsave()` function is used to save a `ggplot` object as an image file. It provides a convenient way to export your plots to various file formats, such as PNG, PDF, SVG, or JPEG.\n\nThe basic syntax of `ggsave()` is as follows:\n\n```\nggsave(filename,\n       plot,\n       device,\n       width,\n       height,\n       units,\n       dpi)\n```\n\n\nYou must give a file name for the output file but all the other options have defaults.\n\n-   plot: The ggplot object you want to save. Defaults to the last created plot.\n-   device: one of \"png\", \"eps\", \"ps\", \"tex\", \"pdf\", \"jpeg\", \"tiff\", \"png\", \"bmp\", \"svg\" or \"wmf\" (windows only). Defaults to the format given by the file extension in filename\n-   width, height units: Plot size in units (\"in\", \"cm\", \"mm\", or \"px\"). Defaults to the size of the plot in the Plots window.\n-   dpi: Plot resolution. \n\nWe can save the figure we just created as a 3 inch x 3 inch png file as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(\"adipocytes.png\",\n       device = \"png\",\n       width = 3,\n       height = 3,\n       units = \"in\",\n       dpi = 300)\n```\n:::\n\n\n\n\nIt is often a good idea to explicitly assign the ggplot object to a variable and use that in the `ggsave()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfig1 <- ggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"gray50\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean, ymax = mean),\n                width = 0.2) +\n  scale_y_continuous(name = \"Adiponectin (pg/mL)\", \n                     limits = c(0, 12), \n                     expand = c(0, 0)) +\n  scale_x_discrete(name = \"Treatment\", \n                   labels = c(\"Control\", \"Nicotinic acid\")) +\n  theme_classic()\n\nggsave(\"adipocytes.png\",\n       plot = fig1,\n       device = \"png\",\n       width = 3,\n       height = 3,\n       units = \"in\",\n       dpi = 300)\n```\n:::\n\n\n\n\n\n## Tidy data\n\nData that is in a format that is easy to work with is often referred to as \"tidy data\". Tidy data is a concept that was introduced by Hadley Wickham in his paper Tidy Data [@Wickham2014-nl]. The paper is available online at <http://vita.had.co.nz/papers/tidy-data.pdf>. \n\nTidy data: \n\n-   Each variable should be in one column. \n-   Each different observation of that variable should be in a different row. \n-  There should be one table for each \"kind\" of data. \n-   If you have multiple tables, they should include a column in the table that allows them to be linked.\n\nThese concepts have been around for a long time and underlie formats enforced in several statistical packages such as SPSS, minitab and SAS. \n\nRecognising the structure of your data and organising it in tidy format is one of the most important step in data analysis. \n\n\n",
    "supporting": [
      "import_to_report_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}