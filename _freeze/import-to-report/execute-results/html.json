{
  "hash": "9bafa474363dc56ee4305e458940c7ab",
  "result": {
    "engine": "knitr",
    "markdown": "# From importing to reporting {#sec-import-to-report}\n\n\n::: {.callout-tip} \n## Just needs proof reading\nYou are reading a work in progress. This page is compete but needs final proof reading.\n:::\n\nIn [Chapter -@sec-first-steps-rstudio] we typed data into R. This is not\nvery practical when you have a lot of data! Instead, we much more\ncommonly import data from a file. In this chapter we go through the\nworkflow from importing, through summarising and plotting to saving a\nsaving the figure.\n\n## Importing data from files\n\nThere are two things you need to know before you can import data from a\nfile.\n\n1.  What format the data are in\n\n    The format of the data determines what *function* you will use to\n    import it. Often the file extension indicates format.\n\n    -   `.txt` a plain text file[^import-to-report-1], where the columns\n        are often separated by a space but might also be separated by a\n        tab, a backslash or forward slash, or some other character\n    -   `.csv` a plain text file where the columns are separated by\n        commas\n    -   `.xlsx` an Excel file More detail on file types was covered in\n        [@sec-file-systems-files]\n\n    However, you should always check the file to make sure it is in the\n    format you expect because there is little to force a match between a\n    file's contents and the extension in its name. You can check by\n    opening the file in a text editor (e.g., Notepad on Windows,\n    TextEdit on Mac) or in RStudio (see below).\n\n2.  Where the file is relative to your working directory\n\n    `R` can only read in a file if you say where it is, *i.e.*, you give\n    its **relative path**. More detail on relative file paths and\n    working directories was covered in\n    [@sec-file-systems-files-working-directories]\n\n[^import-to-report-1]: Plain text files can be opened in notepad or\n    other similar editor and still be readable.\n\nðŸŽ¬ Your turn! If you want to code along you will need to start a new\n(see [@sec-workflow-rstudio-creating-rsp]) then a new script.\n\nThis chapter covers reading `.txt` files and `.csv` files using\n**`tidyverse`** [@tidyverse] functions and excel files using the\n**`readxl`** [@readxl] package. We will demonstrate what needs to be\ndone differently if the file is not in your working directory.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readxl)\n```\n:::\n\n\n### Importing data from `.txt` file\n\nThe data in [adipocytes.txt](data-raw/adipocytes.txt) give the\nconcentration of a hormone called adiponectin in some cells. There are\ntwo columns: the first gives the adiponectin concentration and the\nsecond, treatment, indicates whether the cells were treated with\nnicotinic acid or not. Save this file to the project folder.\n\nA `.txt` extension suggests this is plain text file with columns\nseparated by spaces. However, before we attempt to read it in, when\nshould take a look at it. We can do this from RStudio by clicking on the\nfile in the Files pane. Any plain text file will open in the top left\npane.\n\n::: {#fig-text-data-file-open}\n![](images/text-data-file-open.png)\n\n**A screenshot of RStudio showing the adipocytes.txt data file open over\nthe script.** We can see the columns are separated by spaces which means\nwe can use the `read_table()` function to read it in.\n:::\n\nThe files are separated by spaces as we suspected. We use the\n`read_table()` command to read in plain text files of single columns, or\nwhere the columns are separated by spaces:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadipo <- read_table(\"adipocytes.txt\")\n```\n:::\n\n\nThe data from the file has been read into a dataframe called `adipo`.\nYou will and you will be able to see it in the Environment window.\nClicking on it in the Environment window will open a spreadsheet-like\nview of the dataframe.\n\n### Importing a from a`.csv` file\n\nThe data [seal.csv](data-raw/seal.csv) give the myoglobin concentration\nof skeletal muscle for three species of seal. There are two columns: the\nfirst gives the myoglobin concentration and the second indicates\nspecies.\n\nThe `.csv` extension suggests this is plain text file with columns\nseparated by commas. We will again check this before we attempt to read\nit in. Click on the file in the Files pane - a pop-up will appear for\nfiles ending `.csv` or `.xlsx`. Choose View File[^import-to-report-2].\n\n[^import-to-report-2]: There is also and option to import the dataset.\n    **Do not**Â be tempted to import data this way! Unless you are\n    careful and know what you are doing, your data import will not be\n    scripted or will not be scripted correctly.\n\n::: {#fig-csv-data-file-view}\n![](images/csv-data-file-view.png)\n\n**Screenshot of the Rstudio Files pane**. When you click on a file in\nthe Files pane a pop-up will appear for files ending `.csv` or `.xlsx`.\nChoose *View File*. `.csv` files, as plain text files, will open on the\nleft over the script.\n:::\n\nCSV files will open in the top left pane (Excel files will launch\nExcel). You should be able to see that the file does contain comma\nseparated values. There is a`read_csv()` function which works very like\n\\`read_table():\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseal <- read_csv(\"seals.csv\")\n```\n:::\n\n\n### Importing a from a`.xlsx` file\n\nThe data in [blood.xlsx](data-raw/blood.xlsx) are measurements of\nseveral blood parameters from fifty people with Crohn's disease, a\nlifelong condition where parts of the digestive system become inflamed.\nTwenty-five of people are in the early stages of diagnosis and 25 have\nstarted treatment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblood <- read_excel(\"blood.xlsx\")\n```\n:::\n\n\n### Importing data from a file *not* in your working directory\n\nWhen using an RStudio project, your working directory is the project\nfolder (the folder containing the `.Rproj` file. Suppose our file\n[adipocytes.txt](data-raw/adipocytes.txt) is in a folder, `data-raw`, in\nan Rstudio project called `myproject`. The folder `myproject` will be\nour working directory.\n\n```         \n-- myproject\n   |__myproject.Rproj\n   |__import.R\n   |__data-raw\n      |__adipocytes.txt\n      |__blood.xlsx\n      |__seal.csv\n```\n\nFrom `myproject/` we need to go first into `data-raw/` before finding\n`adipocytes.txt`. This means the *relative path* to `adipocytes.txt` is\n`data-raw/adipocytes.txt`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadipo <- read_table(\"data-raw/adipocytes.txt\")\n```\n:::\n\n\nThe [@sec-file-systems-files-relative-paths] for a file is the path from\nthe working directory to the file. In this case, the working directory\nis `myproject` and the relative path is `data-raw/adipocytes.txt`.\n\nðŸŽ¬ Your turn! Create a folder called `data-raw` inside the project\nfolder and move the data files to it. Now modify the data import code to\nimport seal.csv from `data-raw`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nseal <- read_csv(\"data-raw/seal.csv\")\n```\n:::\n\n\n## Summarising data\n\nWe summarise data using the the **`dplyr`** [@dplyr] package, which\nprovides a set of functions designed for efficient data manipulation.\nThis is a **`tidyverse`** [@tidyverse] package which means it was loaded\nwhen you used `library(tidyverse)`. The approach replies on the data\nbeing organised in a tidy format, meaning each column represents a\nvariable, each row represents an observation, and each cell contains a\nsingle value. The pipeline to summarise data is:\n\n-   Group the data: If you want to summarize your data based on certain\n    groups, you can use the `group_by()`\n\n-   Summarise: Once your data grouped (if necessary), you use\n    `summarise()` with functions like`mean()`, `median()`, `sd()`,\n    `min()`and `max()` within it.\n\nWe will demonstrate summarising using the `adipo` dataframe.\n`adiponectin` is the response and is continuous and `treatment` is an\nexplanatory with categorical with two levels (groups).\n\nThe most useful summary statistics for a continuous variable like\n`adiponectin` are the means, standard deviations, sample sizes and\nstandard errors. We use the `group_by()` and `summarise()` functions\nalong with the functions that do the calculations.\n\nTo create a data frame called `adipo_summary` that contains the means,\nstandard deviations, sample sizes and standard errors for the control\nand nicotinic acid treated samples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadipo_summary <- adipo  |> \n  group_by(treatment) |>\n  summarise(mean = mean(adiponectin),\n            std = sd(adiponectin),\n            n = length(adiponectin),\n            se = std/sqrt(n))\n\n```\n:::\n\n\nTo print the contents of `adipo_summary` you can type its name in the\nconsole:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadipo_summary\n## # A tibble: 2 Ã— 5\n##   treatment  mean   std     n    se\n##   <chr>     <dbl> <dbl> <int> <dbl>\n## 1 control    5.55  1.48    15 0.381\n## 2 nicotinic  7.51  1.79    15 0.463\n```\n:::\n\n\nOr click on `adipo_summary` listed in the environment to open a\nspreadsheet-like view of the dataframe.\n\n### Visualise data\n\nMost commonly, we put the explanatory variable on the *x* axis and the\nresponse variable on the *y* axis. In my opinion, you should also show\nall the raw data points along with some summary values. A continuous\nresponse, particularly one that follows the normal distribution, is best\nsummarised with the mean and the standard error.\n\nWe are going to create a figure like this:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](import-to-report_files/figure-html/unnamed-chunk-11-1.png){width=576}\n:::\n:::\n\n\nEach dots represents a single measurement of adiponectin in a\nstandardised sample of cells -- these are the raw data points. Within\neach treatment group, the data points have been `jittered` -- this is\nadding a small amount of random noise in the *x* direction so points\nwith the same *y*-value do not overlap. The error bars show the mean and\nstandard error of the mean for each treatment group.\n\n#### **`ggplot2`**\n\n**`ggplot2`** [@ggplot2] is a powerful data visualisation package in R\nthat is part of the tidyverse. It provides a flexible and layered\napproach to creating high-quality and customizable graphics.\n\nThe core concept of **`ggplot2`** is to build a plot layer by layer. The\nbasic structure consists of three main components:\n\n1.  *Data*: the data frame to be used for plotting.\n2.  *Aesthetic mappings (aes)*: how variables in the dataset map to\n    visual elements such as *x* and *y* positions, colours, shapes, etc.\n3.  *Geometric objects (geoms)*: the actual graphical elements used to\n    visualize the data, such as points, lines, bars, etc.\n\nTo create a basic plot, you start with the `ggplot()` function and\nprovide the data and aesthetic mappings.\n\n```         \nggplot(data = adipo, aes(x = treatment, y = adiponectin))\n```\n\nYou can add geometric layers to the plot using specific functions such\nas `geom_point()`, `geom_line()`, `geom_bar()`, etc. These functions\ndefine the type of plot you want to create:\n\n```         \nggplot(data = adipo, aes(x = treatment, y = adiponectin)) +\n  geom_point()\n```\n\nIn the figure we are aiming for, we are plotting two dataframes:\n\n-   the `adipo` dataframe which contains the data points themselves\n\n-   the `adipo_summary` dataframe containing and the means and standard\n    errors.\n\nThe dataframes and aesthetics for ggplot can be specified *within a\n`geom_xxxx`* (rather than in the `ggplot()`). This is very useful if the\ngeom only applies to some of the data you want to plot.\n\n::: callout-tip\n## Tip: `ggplot()`\n\nYou put the `data` argument and `aes()` inside `ggplot()` if you want\nall the `geoms` to use that dataframe and variables. If you want a\n*different* dataframe for a `geom`, put the `data` argument and `aes()`\ninside the `geom_xxxx()`\n:::\n\nI will build the plot up in small steps. You do not need to repeat the\ncode at each step - simply edit your *existing* `ggplot()` command as we\ngo.\n\nWe will plot the data points first. Notice that we have given the data\nargument and the aesthetics *inside* the `geom_point()`. This is because\nit is only in this geom that we want to use the dataframe with the raw\ndata. The variables `treatment` and `adiponectin` are in the `adipo`\ndataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, \n             aes(x = treatment, y = adiponectin))\n```\n\n::: {.cell-output-display}\n![](import-to-report_files/figure-html/unnamed-chunk-12-1.png){width=576}\n:::\n:::\n\n\nSo that the data points don't overlap, we can add some random jitter in\nthe *x* direction (edit your existing code):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, \n             aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0))\n```\n\n::: {.cell-output-display}\n![](import-to-report_files/figure-html/unnamed-chunk-13-1.png){width=576}\n:::\n:::\n\n\nNote that `position = position_jitter(width = 0.1, height = 0)` is\ninside the `geom_point()` parentheses, after the `aes()` and a comma.\n\nWe've set the vertical jitter to 0 because, in contrast to the\ncategorical *x*-axis, movement on the *y*-axis has meaning (the\nadiponectin levels).\n\nLet's make the points a light grey (edit your existing code):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, \n             aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"grey30\")\n```\n\n::: {.cell-output-display}\n![](import-to-report_files/figure-html/unnamed-chunk-14-1.png){width=576}\n:::\n:::\n\n\nNow to add the error bars. These go from one standard error *below* the\nmean to one standard error *above* the mean.\n\nAdd a `geom_errorbar()` for error bars (edit your existing code):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"grey30\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) \n```\n\n::: {.cell-output-display}\n![](import-to-report_files/figure-html/unnamed-chunk-15-1.png){width=576}\n:::\n:::\n\n\nWe have specified the `adipo_summary` dataframe and the variables three\nvariables given â€“`treatment`, `mean` and `se` â€“ are in that dataframe.\n\nThere are several ways you could add the mean. You could use\n`geom_point()`. I like to use `geom_errorbar()` again with the `ymin`\nand `ymax` both set to the mean so that I just get a line at the mean.\n\nAdd a `geom_errorbar()` for the mean (edit your existing code):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"grey30\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean, ymax = mean),\n                width = 0.2)\n```\n\n::: {.cell-output-display}\n![](import-to-report_files/figure-html/unnamed-chunk-16-1.png){width=576}\n:::\n:::\n\n\nAlter the axis labels and limits using `scale_y_continuous()` and\n`scale_x_discrete()` (edit your existing code):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"grey30\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean, ymax = mean),\n                width = 0.2) +\n  scale_y_continuous(name = \"Adiponectin (pg/mL)\", \n                     limits = c(0, 12), \n                     expand = c(0, 0)) +\n  scale_x_discrete(name = \"Treatment\", \n                   labels = c(\"Control\", \"Nicotinic acid\"))\n```\n\n::: {.cell-output-display}\n![](import-to-report_files/figure-html/unnamed-chunk-17-1.png){width=576}\n:::\n:::\n\n\nYou only need to use `scale_y_continuous()` and `scale_x_discrete()` to\nuse labels that are different from those in the dataset. Often this is\nto use proper terminology or to captialise.\n\nFormat the figure in a way that is more suitable for including in a\nreport using `theme_classic()` (edit your existing code):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"gray30\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean, ymax = mean),\n                width = 0.2) +\n  scale_y_continuous(name = \"Adiponectin (pg/mL)\", \n                     limits = c(0, 12), \n                     expand = c(0, 0)) +\n  scale_x_discrete(name = \"Treatment\", \n                   labels = c(\"Control\", \"Nicotinic acid\")) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](import-to-report_files/figure-html/unnamed-chunk-18-1.png){width=576}\n:::\n:::\n\n\nThe `ggsave()` function is used to save a `ggplot` object as an image\nfile. It provides a convenient way to export your plots to various file\nformats, such as PNG, PDF, SVG, or JPEG.\n\nThe basic syntax of `ggsave()` is as follows:\n\n```         \nggsave(filename,\n       plot,\n       device,\n       width,\n       height,\n       units,\n       dpi)\n```\n\nYou *must* give a file name for the output file but all the other\noptions have defaults.\n\n-   plot: The ggplot object you want to save. Defaults to the last\n    created plot.\n-   device: one of \"png\", \"eps\", \"ps\", \"tex\", \"pdf\", \"jpeg\", \"tiff\",\n    \"png\", \"bmp\", \"svg\" or \"wmf\" (windows only). Defaults to the format\n    given by the file extension in filename\n-   width, height units: Plot size in units (\"in\", \"cm\", \"mm\", or \"px\").\n    Defaults to the size of the plot in the Plots window.\n-   dpi: Plot resolution.\n\nIt is valuable to give explicit values even where there are defaults to\nensure you can reproduce the figure.\n\nWe can save the figure we just created as a 3 inch x 3 inch png file as\nfollows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(\"adipocytes.png\",\n       device = \"png\",\n       width = 3,\n       height = 3,\n       units = \"in\",\n       dpi = 300)\n```\n:::\n\n\nIt is often a good idea to explicitly assign the ggplot object to a\nvariable and use that in the `ggsave()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfig1 <- ggplot() +\n  geom_point(data = adipo, aes(x = treatment, y = adiponectin),\n             position = position_jitter(width = 0.1, height = 0),\n             colour = \"gray30\") +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean - se, ymax = mean + se),\n                width = 0.3) +\n  geom_errorbar(data = adipo_summary, \n                aes(x = treatment, ymin = mean, ymax = mean),\n                width = 0.2) +\n  scale_y_continuous(name = \"Adiponectin (pg/mL)\", \n                     limits = c(0, 12), \n                     expand = c(0, 0)) +\n  scale_x_discrete(name = \"Treatment\", \n                   labels = c(\"Control\", \"Nicotinic acid\")) +\n  theme_classic()\n\nggsave(\"adipocytes.png\",\n       plot = fig1,\n       device = \"png\",\n       width = 3,\n       height = 3,\n       units = \"in\",\n       dpi = 300)\n```\n:::\n\n\n## Summary\n\n1.  To import data you need to match the file format (e.g., `.txt`,\n    `.csv`, `.xlsx`) to the appropriate import function (e.g.,\n    `read_table()`, `read_csv()`, or `read_excel()` and give the\n    *relative path* to the file.\n2.  Opening files in RStudio or Excel before trying to import will help\n    you determine the format and delimiter used.\n3.  To summarising data in more than one group, we use `group_by()` then\n    `summarise()` with functions like `mean()`, `sd()` and `length()`.\n4.  We build plots using `ggplot()` and add layers such as\n    `geom_point()` and `geom_errorbar()`. Axes can be customised axes\n    using `scale_x_####()` or `scale_y_####()`and `theme_classic()`\n    makes the plot look more those in a scientific report.\n5.  Save plots made with **`ggplot2`** with `ggsave()`.\n",
    "supporting": [
      "import-to-report_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}